# Copyright 2025 Xin Huang
#
# GNU General Public License v3.0
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, please see
#
#    https://www.gnu.org/licenses/gpl-3.0.en.html


import allel
import gzip
import os
import numpy as np
import pandas as pd
import multiprocessing
from multiprocessing import Process, Queue
from typing import Any, Dict, List, Tuple
from sstar.utils import read_data, py2round, read_mapped_region_file, cal_matchpct


# @profile
def calc_match_pct(
    vcf: str,
    ref_ind_file: str,
    tgt_ind_file: str,
    src_ind_file: str,
    anc_allele_file: str,
    output: str,
    thread: int,
    score_file: str,
    mapped_region_file: str
) -> None:
    """
    Calculate p-values for S* haplotypes in the target population with source genomes.

    Parameters
    ----------
    vcf : str
        Name of the VCF file containing genotypes.
    ref_ind_file : str
        Name of the file containing sample information from reference populations.
    tgt_ind_file : str
        Name of the file containing sample information from target populations.
    src_ind_file : str
        Name of the file containing sample information from source populations.
    anc_allele_file : str
        Name of the file containing ancestral allele information.
    output : str
        Name of the output file.
    thread : int
        Number of threads.
    score_file : str
        Name of the file containing S* scores calculated by `s-star score`.
    mapped_region_file : str
        Name of the BED file containing mapped regions.
    """
    ref_data, ref_samples, tgt_data, tgt_samples, src_data, src_samples = read_data(
        vcf, ref_ind_file, tgt_ind_file, src_ind_file, anc_allele_file
    )

    res = []
    chr_names = ref_data.keys()

    mapped_intervals = read_mapped_region_file(mapped_region_file)
    data, windows, samples = _read_score_file(score_file, chr_names, tgt_samples)
    sample_size = len(samples)

    header = "chrom\tstart\tend\tsample\tmatch_rate\tsrc_sample"

    if thread > 1:
        thread = min(os.cpu_count() - 1, sample_size, thread)
    res = _cal_tgt_match_pct_manager(
        data,
        mapped_intervals,
        samples,
        tgt_samples,
        src_samples,
        tgt_data,
        src_data,
        sample_size,
        thread,
    )

    with open(output, "w") as o:
        o.write(header + "\n")
        o.write("\n".join(res) + "\n")


# @profile
def _read_score_file(
    score_file: str,
    chr_names: List[str],
    tgt_samples: List[str]
) -> Tuple[Dict, Dict, str, List[str]]:
    """
    Helper function for reading the file generated by `sstar score`.

    Parameters
    ----------
    score_file : str
        Name of the file containing S* scores generated by `sstar score`.
    chr_names : list of str
        List containing names of chromosomes for analysis.
    tgt_samples : list of str
        List containing names of samples from the target population for analysis.

    Returns
    -------
    data : dict
        Dictionary containing S* for analysis.
    windows : dict
        Dictionary containing windows for analysis.
    header : str
        Header from the file generated by `sstar score`.
    samples : list of str
        List containing names of samples in the target population for analysis.
    """
    data = dict()
    windows = dict()
    for c in chr_names:
        windows[c] = []
    samples = []
    with open(score_file, "r") as f:
        header = f.readline().rstrip()
        for line in f.readlines():
            line = line.rstrip()
            elements = line.split("\t")
            chr_name = elements[0]
            win_start = elements[1]
            win_end = elements[2]
            sample = elements[3]
            if sample not in tgt_samples:
                continue
            if elements[6] == "NA":
                continue
            if sample not in data.keys():
                data[sample] = []
                samples.append(sample)
            data[sample].append(line)
            windows[c].append((int(win_start), int(win_end)))

    return data, windows, samples


def _cal_tgt_match_pct_manager(
    data: Dict,
    mapped_intervals: Dict,
    samples: List[str],
    tgt_samples: List[str],
    src_samples: List[str],
    tgt_data: Dict,
    src_data: Dict,
    sample_size: int,
    thread: int
) -> List[float]:
    """
    Manager function to calculate match percents in target populations using multiprocessing.

    Parameters
    ----------
    data : dict
        Lines from the output file created by `sstar score`.
    mapped_intervals : dict
        Dictionary of tuples containing mapped regions across the genome.
    samples : list of str
        Sample information for individuals whose match percents are to be estimated.
    tgt_samples : list of str
        Sample information from target populations.
    src_samples : list of str
        Sample information from source populations.
    tgt_data : dict
        Genotype data from target populations.
    src_data : dict
        Genotype data from source populations.
    sample_size : int
        Number of individuals analyzed.
    thread : int
        Number of threads.

    Returns
    -------
    res : list of float
        Match percents for target populations.
    """
    try:
        from pytest_cov.embed import cleanup_on_sigterm
    except ImportError:
        pass
    else:
        cleanup_on_sigterm()

    res = []
    in_queue, out_queue = Queue(), Queue()
    workers = [
        Process(
            target=_cal_tgt_match_pct_worker,
            args=(
                in_queue,
                out_queue,
                mapped_intervals,
                tgt_data,
                src_data,
                src_samples,
                len(tgt_samples),
            ),
        )
        for ii in range(thread)
    ]

    for t in samples:
        index = tgt_samples.index(t)
        in_queue.put((index, data[t]))

    try:
        for worker in workers:
            worker.start()
        for s in range(sample_size):
            item = out_queue.get()
            if item != "":
                res.append(item)
        for worker in workers:
            worker.terminate()
    finally:
        for worker in workers:
            worker.join()

    return res


def _cal_tgt_match_pct_worker(
    in_queue: multiprocessing.Queue,
    out_queue: multiprocessing.Queue,
    mapped_intervals: Dict,
    tgt_data: Dict,
    src_data: Dict,
    src_samples: List[str],
    sample_size: int
) -> None:
    """
    Worker function to calculate match percents in target populations.

    Parameters
    ----------
    in_queue : multiprocessing.Queue
        Queue instance to receive parameters from the manager.
    out_queue : multiprocessing.Queue
        Queue instance to send results back to the manager.
    mapped_intervals : dict
        Dictionary of tuples containing mapped regions across the genome.
    tgt_data : dict
        Genotype data from target populations.
    src_data : dict
        Genotype data from source populations.
    src_samples : list of str
        List containing sample information for source populations.
    sample_size : int
        Number of individuals analyzed.
    """
    while True:
        index, data = in_queue.get()
        res = _cal_match_pct_ind(
            data, index, mapped_intervals, tgt_data, src_data, src_samples, sample_size
        )
        out_queue.put("\n".join(res))


# @profile
def _cal_match_pct_ind(
    data: Dict,
    tgt_ind_index: int,
    mapped_intervals: Dict,
    tgt_data: Dict,
    src_data: Dict,
    src_samples: List[str],
    sample_size: int
) -> List[Any]:
    """
    Helper function for calculating p-values in individuals.

    Parameters
    ----------
    data : dict
        Dictionary containing S* for analysis.
    tgt_ind_index : int
        Index of the target individual for analysis.
    mapped_intervals : dict
        Dictionary of tuples containing mapped regions across the genome.
    tgt_data : dict
        Genotype data from target populations.
    src_data : dict
        Genotype data from source populations.
    src_samples : list of str
        List of samples from source populations.
    sample_size : int
        Number of individuals analyzed.

    Returns
    -------
    res : list
        List containing estimated p-values and other statistics.
    """
    res = []
    for line in data:
        elements = line.split("\t")
        chr_name = elements[0]
        win_start, win_end = elements[1], elements[2]
        sample = elements[3]

        s_star_snps = elements[-1].split(",")
        s_start, s_end = s_star_snps[0], s_star_snps[-1]
        key1 = win_start + "-" + win_end
        key2 = s_start + "-" + s_end

        for src_ind_index in range(len(src_samples)):
            src_sample = src_samples[src_ind_index]
            hap1_res = cal_matchpct(
                chr_name,
                mapped_intervals,
                tgt_data,
                src_data,
                tgt_ind_index,
                src_ind_index,
                0,
                int(win_start),
                int(win_end),
                sample_size,
            )
            hap2_res = cal_matchpct(
                chr_name,
                mapped_intervals,
                tgt_data,
                src_data,
                tgt_ind_index,
                src_ind_index,
                1,
                int(win_start),
                int(win_end),
                sample_size,
            )

            hap1_match_pct = hap1_res[-1]
            hap2_match_pct = hap2_res[-1]
            hap_match_pct = "NA"

            if (hap1_match_pct != "NA") and (hap2_match_pct != "NA"):
                hap_match_pct = (hap1_match_pct + hap2_match_pct) / 2

            line = f"{chr_name}\t{win_start}\t{win_end}\t{sample}\t{hap_match_pct}\t{src_sample}"
            res.append(line)
    return res
